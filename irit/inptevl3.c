/*****************************************************************************
*   "Irit" - the 3d (not only polygonal) solid modeller.		     *
*									     *
* Written by:  Gershon Elber				Ver 0.2, Mar. 1990   *
******************************************************************************
* (C) Gershon Elber, Technion, Israel Institute of Technology                *
******************************************************************************
*   Module to evaluate the binary tree generated by the InptPrsr module.     *
*   All the objects are handled the same but the numerical one, which is     *
* moved as a IrtRType and not as an object (only internally within this	     *
* module) as it is frequently used and consumes much less memory this way.   *
*****************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <string.h>
#include "program.h"
#include "ctrl-brk.h"
#include "objects.h"
#include "allocate.h"
#include "inptprsg.h"
#include "inptprsl.h"

IRIT_STATIC_DATA int
    GlblDebugFuncLevel = 0;
IRIT_STATIC_DATA IrtRType
    GlblObjCmpEps = IRIT_UEPS;

static int InptEvalCompareObjectAux(IPObjectStruct *PObj1,
				    IPObjectStruct *PObj2,
				    int *OnlyEquality,
				    CagdRType Eps);
static void RebindVariable(ParseTree *Root, IPObjectStruct *PObj);
static ParseTree *InptEvalFetchExpression(ParseTree *Root, int i, int n);
static int InptEvalCountNumExpressions(ParseTree *Root);
static void InptEvalWarningNewFunc(UserDefinedFuncDefType *UserFunc);
static char *InptEvalNewFuncHasFree(UserDefinedFuncDefType *UserFunc,
				    ParseTree *FuncBody);
static void InptEvalDeleteFunc(UserDefinedFuncDefType *UserFunc,
			       int DeleteSelf);

/*****************************************************************************
* DESCRIPTION:                                                               M
* Prints help on the given subject HelpHeader.				     M
*   A match is if the HelpHeader isa prefix of help file line.		     M
*                                                                            *
* PARAMETERS:                                                                M
*   HelpHeader:   Subject of help needed.                                    M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalPrintHelp                                                        M
*****************************************************************************/
void InptEvalPrintHelp(const char *HelpHeader)
{
#ifndef IRIT_QUIET_STRINGS
    IRIT_STATIC_DATA char
	*DefaultHelp = NULL;
    const char *Path;
    char s[IRIT_LINE_LEN];
    FILE *f;

    Path = searchpath(GlblHelpFileName);

    if (DefaultHelp == NULL)
	DefaultHelp = IritStrdup("Commands");

    if (IRT_STR_ZERO_LEN(HelpHeader))
	HelpHeader = DefaultHelp;	    /* Print a list of all commands. */

    if ((f = fopen(Path, "r")) == NULL) {
	IRIT_WNDW_FPRINTF2("Cannot open help file \"%s\".\n",
			   GlblHelpFileName);
	return;
    }

    while (fgets(s, IRIT_LINE_LEN - 1, f) != NULL) {
	if (strnicmp(HelpHeader, s, strlen(HelpHeader)) == 0) {
	    /* Found match - print it. */
	    while (fgets(s, IRIT_LINE_LEN-1, f) != NULL && s[0] != '$') {
		if (s[strlen(s) - 1] < ' ')
		    s[strlen(s) - 1] = 0;			/* No CR/LF. */

		IRIT_WNDW_PUT_STR(&s[1]);		     /* Skip char 1. */
	    }
	    fclose(f);
	    return;
	}
    }

    fclose(f);

    IRIT_WNDW_FPRINTF2("No help on %s\n", HelpHeader);
#endif /* !IRIT_QUIET_STRINGS */
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Compares two objects with comparison operator as in Root.		     M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:         Type of comparison requested (=, <, >, etc.).              M
*   Left, Right:  Two objects to compare.                                    M
*   IError:       Type of error if was one.                                  M
*   CError:       Description of error if was one.                           M
*                                                                            *
* RETURN VALUE:                                                              M
*   ParseTree *:  Comparison result as a numeric value of >0, 0, <0.         M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalCompareObject                                                    M
*****************************************************************************/
ParseTree *InptEvalCompareObject(ParseTree *Root,
				 ParseTree *Left,
				 ParseTree *Right,
				 InptPrsrEvalErrType *IError,
				 char *CError)
{
    int OnlyEquality = FALSE,
	Cmp = 0;

    if (Left -> PObj -> ObjType != Right -> PObj -> ObjType) {
	*IError = IE_ERR_INCOMPARABLE_TYPES;
	strcpy(CError, "");
	return NULL;
    }

    Cmp = InptEvalCompareObjectAux(Left -> PObj, Right -> PObj,
				   &OnlyEquality, GlblObjCmpEps);

    switch (Root -> NodeKind) {
	case IP_TKN_CMP_EQUAL:
	    Cmp = Cmp == 0;
	    break;
	case IP_TKN_CMP_NOTEQUAL:
	    Cmp = Cmp != 0;
	    break;
	case IP_TKN_CMP_LSEQUAL:
	case IP_TKN_CMP_GTEQUAL:
	case IP_TKN_CMP_LESS:
	case IP_TKN_CMP_GREAT:
	    if (OnlyEquality) {
		*IError = IE_ERR_ONLYEQUALITY_TEST;
		strcpy(CError, "");
		return NULL;
	    }
	    else {
		switch (Root -> NodeKind) {
		    case IP_TKN_CMP_LSEQUAL:
		        Cmp = Cmp <= 0;
		        break;
		    case IP_TKN_CMP_GTEQUAL:
		        Cmp = Cmp >= 0;
			break;
		    case IP_TKN_CMP_LESS:
		        Cmp = Cmp < 0;
			break;
		    case IP_TKN_CMP_GREAT:
		        Cmp = Cmp > 0;
			break;
		}
	    }
	    break;
	default:
	    IRIT_FATAL_ERROR("A comparison operator expected.");
	    break;
    }

    Root -> PObj = IPGenNUMValObject(Cmp);
    Root -> PObj -> Count++;
    return Root;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Sets the object comparison epslion tolerance.				     M
*                                                                            *
* PARAMETERS:                                                                M
*   NewEps:  New epsilon to use for object comparison.		             M
*                                                                            *
* RETURN VALUE:                                                              M
*   IrtRType:  Old value.                                                    M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrSetCmpObjEps                                                     M
*****************************************************************************/
IrtRType InptPrsrSetCmpObjEps(IrtRType NewEps)
{
    IrtRType OldEps = GlblObjCmpEps;

    GlblObjCmpEps = NewEps;

    return OldEps;
}

/*****************************************************************************
* DESCRIPTION:                                                               *
* Compares two objects.                                                      *
*                                                                            *
* PARAMETERS:                                                                *
*   PObj1, PObj2:  The two objects to compare.                               *
*   OnlyEquality:  Return TRUE if only (in)equality can be tested, 	     *
*		   Greater/Less than, otherwise.                             *
*   Eps:           Tolerance of equality.		                     *
*                                                                            *
* RETURN VALUE:                                                              *
*   int:       +/-1 if not equal, 0 if equal.                                *
*                                                                            *
* KEYWORDS:                                                                  *
*   InptEvalCompareObject                                                    *
*****************************************************************************/
static int InptEvalCompareObjectAux(IPObjectStruct *PObj1,
				    IPObjectStruct *PObj2,
				    int *OnlyEquality,
				    CagdRType Eps)
{
    int i, j,
	Cmp = 0;
    IPPolygonStruct *Pl1, *Pl2;
    IPObjectStruct *PObj1Tmp, *PObj2Tmp;

    if (PObj1 -> ObjType != PObj2 -> ObjType) {
	*OnlyEquality = TRUE;
	return 1;
    }

    switch (PObj1 -> ObjType) {
	case IP_OBJ_LIST_OBJ:
	    for (i = 0; (PObj1Tmp = IPListObjectGet(PObj1, i)) != NULL; i++) {
		if ((PObj2Tmp = IPListObjectGet(PObj2, i)) == NULL ||
		    InptEvalCompareObjectAux(PObj1Tmp, PObj2Tmp,
					     OnlyEquality, Eps) != 0) {
		    Cmp = 1;
		    break;
		}
	    }
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_NUMERIC:
	    if ((Cmp = (int) IRIT_SIGN(PObj1 -> U.R - PObj2 -> U.R)) != 0) {
		if (IRIT_APX_EQ_EPS(PObj1 -> U.R, PObj2 -> U.R, Eps))
		    Cmp = 0;
	    }	    
	    break;
	case IP_OBJ_POINT:
	    Cmp = IRIT_PT_APX_EQ_EPS(PObj1 -> U.Pt, PObj2 -> U.Pt, Eps) == 0;
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_VECTOR:
	    Cmp = IRIT_PT_APX_EQ_EPS(PObj1 -> U.Vec, PObj2 -> U.Vec, Eps) == 0;
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_PLANE:
	    Cmp = IRIT_PLANE_APX_EQ_EPS(PObj1 -> U.Plane,
				        PObj2 -> U.Plane, Eps) == 0;
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_CTLPT:
	    Cmp = 1;
	    if (PObj1 -> U.CtlPt.PtType == PObj2 -> U.CtlPt.PtType) {
		for (i = !CAGD_IS_RATIONAL_PT(PObj1 -> U.CtlPt.PtType);
		     i <= CAGD_NUM_OF_PT_COORD(PObj1 -> U.CtlPt.PtType);
		     i++)
		    if (!IRIT_APX_EQ_EPS(PObj1 -> U.CtlPt.Coords[i],
				    PObj2 -> U.CtlPt.Coords[i], Eps))
			break;

		if (i > CAGD_NUM_OF_PT_COORD(PObj1 -> U.CtlPt.PtType))
		    Cmp = 0;
	    }
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_MATRIX:
	    for (i = 0; i < 4; i++)
		for (j = 0; j < 4; j++)
		    if (!IRIT_APX_EQ_EPS((*PObj1 -> U.Mat)[i][j],
				    (*PObj2 -> U.Mat)[i][j], Eps))
			Cmp = 1;
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_POLY:
	    for (Pl1 = PObj1 -> U.Pl, Pl2 = PObj2 -> U.Pl;
		 Cmp == 0 && Pl1 != NULL && Pl2 != NULL;
		 Pl1 = Pl1 -> Pnext, Pl2 = Pl2 -> Pnext) {
		IPVertexStruct
		    *V1 = Pl1 -> PVertex,
		    *V2 = Pl2 -> PVertex;

		if (V1 != NULL && V2 != NULL) {
		    do {
		        /* Polys will be considered equal if same point. */
		        Cmp = !IRIT_PT_APX_EQ_EPS(V1 -> Coord, V2 -> Coord, Eps);

			V1 = V1 -> Pnext;
			V2 = V2 -> Pnext;
		    }
		    while (!Cmp &&
			   V1 != NULL && V2 != NULL &&
			   V1 != Pl1 -> PVertex && V2 != Pl2 -> PVertex);
		}

		if (Cmp == 0 &&
		    (((V1 == NULL || V1 == Pl1 -> PVertex) ^
		      (V2 == NULL || V2 == Pl2 -> PVertex)) ||
		     (V1 == NULL && V2 != NULL) ||
		     (V1 != NULL && V2 == NULL)))
		     Cmp = 1;
	    }
	    *OnlyEquality = TRUE;
	    if (Cmp == 0 && ((Pl1 == NULL) ^ (Pl2 == NULL)))
		Cmp = 1;
	    break;
	case IP_OBJ_CURVE:
	    Cmp = !CagdCrvsSame(PObj1 -> U.Crvs, PObj2 -> U.Crvs, Eps);
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_SURFACE:
	    Cmp = !CagdSrfsSame(PObj1 -> U.Srfs, PObj2 -> U.Srfs, Eps);
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_TRISRF:
	    Cmp = !TrngTriSrfsSame(PObj1 -> U.TriSrfs,
				   PObj2 -> U.TriSrfs, Eps);
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_TRIVAR:
	    Cmp = !TrivTVsSame(PObj1 -> U.Trivars, PObj2 -> U.Trivars, Eps);
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_MULTIVAR:
	    Cmp = !MvarMVsSame(PObj1 -> U.MultiVars,
			       PObj2 -> U.MultiVars, Eps);
	    *OnlyEquality = TRUE;
	    break;
	case IP_OBJ_STRING:
	    Cmp = strcmp(PObj1 -> U.Str, PObj2 -> U.Str);
	    OnlyEquality = FALSE;
	    break;
	default:
	    break;
    }

    return Cmp;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Executes the IF expression.                                                M
*                                                                            *
* PARAMETERS:                                                                M
*   Cond:        To evaluate in the IF sentence.                             M
*   CondTrue:    Optional, execute if Cond is TRUE.                          M
*   CondFalse:   Optional, execute if Cond is FALSE.                         M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalIfCondition                                                      M
*****************************************************************************/
void InptEvalIfCondition(ParseTree *Cond,
			 ParseTree *CondTrue,
			 ParseTree *CondFalse)
{
    if ((Cond = InptPrsrEvalTree(Cond, IP_EVAL_BASE_LEVEL + 1)) != NULL &&
	Cond -> PObj != NULL &&
	IP_IS_NUM_OBJ(Cond -> PObj)) {
	if (IRIT_APX_EQ(Cond -> PObj -> U.R, 0.0)) {
	    if (CondFalse != NULL)
	        InptPrsrEvalTree(CondFalse, IP_EVAL_BASE_LEVEL);
	}
	else {
	    if (CondTrue != NULL)
		InptPrsrEvalTree(CondTrue, IP_EVAL_BASE_LEVEL);
	}
    }
    else {
	IPGlblEvalError = IE_ERR_IF_HAS_NO_COND;
	strcpy(IPGlblCharData, "");
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Executes the FOR expression loop.					     M
*   As InptPrsrEvalTree routine is destructive on its input tree, we must    M
* make a copy of the body before executing it!			     	     M
*   We wish we could access the loop variable directly, but the user might   M
* free them in the loop - so me must access it by name.			     M
*                                                                            *
* PARAMETERS:                                                                M
*   PStart:    Initailization expression.                                    M
*   PInc:      Increment expression.                                         M
*   PEnd:      Termination expression.                                       M
*   PBody:     Body of loop expression.                                      M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalForLoop                                                          M
*****************************************************************************/
void InptEvalForLoop(ParseTree *PStart,
		     ParseTree *PInc,
		     ParseTree *PEnd,
		     ParseTree *PBody)
{
    int i, NumOfExpr, LoopCount;
    char
	*LoopVarName = NULL;
    IrtRType LoopVar, StartVal, Increment, EndVal;
    ParseTree *PTemp;
    IPObjectStruct *PLoopVar;

    /* Find the only two cases where loop variable is allowed - when the  */
    /* given starting value is a parameter, or assignment to parameter... */
    if (PStart -> NodeKind == IP_TKN_PARAMETER)
	LoopVarName = IP_GET_OBJ_NAME(PStart -> PObj);
    else if (PStart -> NodeKind == IP_TKN_EQUAL &&
	     PStart -> Left -> NodeKind == IP_TKN_PARAMETER) {
	LoopVarName = IP_GET_OBJ_NAME(PStart -> Left -> PObj);
	/* Rebind the iteration variable to body - it might be new: */
	RebindVariable(PBody, PStart -> Left -> PObj);
	if (IritDBGetObjByName(LoopVarName) == NULL)	/* It is really new. */
	    PStart -> Left -> PObj -> Count++;
    }

    /* Evaluate starting value: */
    PStart = InptPrsrEvalTree(PStart, IP_EVAL_BASE_LEVEL + 1);
    /* Evaluate increment value: */
    PInc   = InptPrsrEvalTree(PInc, IP_EVAL_BASE_LEVEL + 1);
    /* Evaluate end value: */
    PEnd   = InptPrsrEvalTree(PEnd, IP_EVAL_BASE_LEVEL + 1);
    if (IPGlblEvalError ||
	PStart == NULL || PInc == NULL || PEnd == NULL)
	return;
    StartVal = PStart -> PObj -> U.R;
    Increment = PInc -> PObj -> U.R;
    EndVal = PEnd -> PObj -> U.R;

    /* Num. of expr. in the body. */
    NumOfExpr = InptEvalCountNumExpressions(PBody);
    for (LoopVar = StartVal, LoopCount = 0;
	IRIT_APX_EQ(LoopVar, EndVal) ||
	(Increment > 0 ? LoopVar <= EndVal : LoopVar >= EndVal);
	LoopVar += Increment, LoopCount++) {
	if (IPGlblEvalError || GlblFatalError)
	    return;
	if (LoopVarName != NULL) {
	    if ((PLoopVar = IritDBGetObjByName(LoopVarName)) != NULL &&
		IP_IS_NUM_OBJ(PLoopVar))
		PLoopVar -> U.R = LoopVar;		 /* Update loop var. */
	    else {
		IPGlblEvalError = IE_ERR_MODIF_ITER_VAR;
		strcpy(IPGlblCharData, LoopVarName);
	    }
	}

	for (i = 0; i < NumOfExpr; i++) {
	    PTemp = InptEvalFetchExpression(PBody, i, NumOfExpr);
	    if (LoopCount == 0 && InptPrsrTypeCheck(PTemp, 0) == ERROR_EXPR)
		return;
	    else {
		if (LoopVar == EndVal) {
		    /* Use the original tree. Note we must evaluate the      */
		    /* original tree at least once as ObjType's are updated. */
		    /* Eval as its top level... */
		    InptPrsrEvalTree(PTemp, IP_EVAL_BASE_LEVEL);
		}
		else {
		    PTemp = InptPrsrCopyTree(PTemp);
		    /* Eval as its top level... */
		    InptPrsrEvalTree(PTemp, IP_EVAL_BASE_LEVEL);
		    InptPrsrFreeTree(PTemp);	     /* Not needed any more. */
		}
	    }
	}
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Executes the WHILE expression loop.                                        M
*   As InptPrsrEvalTree routine is destructive on its input tree, we must    M
* make a copy of the body before executing it!                               M
*   Variables used in the conditional expression must be declared prior to   M
* the while loop                                                             M
*                                                                            *
* PARAMETERS:                                                                M
*   PCond:     Termination expression.                                       M
*   PBody:     Body of loop expression.                                      M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalWhileLoop                                                        M
*****************************************************************************/
void InptEvalWhileLoop(ParseTree *PCond, ParseTree *PBody)
{
    int i, NumOfExpr;
    int Cond;
    ParseTree *PTemp;

    /* Num. of expr. in the body. */
    NumOfExpr = InptEvalCountNumExpressions(PBody);

    /* actually a while loop */
    while (TRUE) {
        PTemp = InptPrsrCopyTree(PCond);       /* Copy the conditional expr. */
	/* Evaluate conditional value. */
        PTemp = InptPrsrEvalTree(PTemp, IP_EVAL_BASE_LEVEL + 1);
        Cond = (int) (PTemp -> PObj -> U.R + 0.5);    /* extract the result. */
        InptPrsrFreeTree(PTemp);                     /* Not needed any more. */

        if (!Cond)
	    break;

        /* evaluate each of the expressions in the body... */
        for (i = 0; i < NumOfExpr; i++) {
            PTemp = InptEvalFetchExpression(PBody, i, NumOfExpr);
            PTemp = InptPrsrCopyTree(PTemp);
	    /* Eval as its top level... */
            InptPrsrEvalTree(PTemp, IP_EVAL_BASE_LEVEL);
            InptPrsrFreeTree(PTemp);                /* Not needed any more. */
        }
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               *
* Rebinds a variable - given a tree, scan it and update each occurance of    *
* that variable to point to PObj.					     *
*                                                                            *
* PARAMETERS:                                                                *
*   Root:        Tree to rebind.                                             *
*   PObj:        Variable to rebind to.                                      *
*                                                                            *
* RETURN VALUE:                                                              *
*   void                                                                     *
*****************************************************************************/
static void RebindVariable(ParseTree *Root, IPObjectStruct *PObj)
{
    if (Root == NULL)
	return;

    if (IP_IS_FUNCTION(Root -> NodeKind)) {	       /* All the functions. */
	RebindVariable(Root -> Right, PObj);
	return;
    }

    switch (Root -> NodeKind) {
	case IP_TKN_DIV:
	case IP_TKN_MINUS:
	case IP_TKN_MULT:
	case IP_TKN_PLUS:
	case IP_TKN_POWER:

	case IP_TKN_COMMA:
	case IP_TKN_COLON:
	case IP_TKN_EQUAL:
	case IP_TKN_CMP_EQUAL:
	case IP_TKN_CMP_NOTEQUAL:
	case IP_TKN_CMP_LSEQUAL:
	case IP_TKN_CMP_GTEQUAL:
	case IP_TKN_CMP_LESS:
	case IP_TKN_CMP_GREAT:
	case IP_TKN_BOOL_OR:
	case IP_TKN_BOOL_AND:
	    RebindVariable(Root -> Right, PObj);
	    RebindVariable(Root -> Left, PObj);
	    return;

	case IP_TKN_UNARMINUS:
	case IP_TKN_BOOL_NOT:
	    RebindVariable(Root -> Right, PObj);
	    return;

	case IP_TKN_NUMBER:
	    return;

	case IP_TKN_PARAMETER:
	case IP_TKN_STRING:
	    if (strcmp(IP_GET_OBJ_NAME(Root -> PObj),
		       IP_GET_OBJ_NAME(PObj)) == 0) {
		IPFreeObject(Root -> PObj);
		Root -> PObj = PObj;
		PObj -> Count++;
	    }
            return;

	case IP_TKN_START:
	    return;

	default:
	    IRIT_FATAL_ERROR("RebindVariable: Undefined ParseTree type, exit");
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Marks all undefined objects in bindings as "to be assigned".               M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:        Tree to rebind.                                             M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrMarkToBeAssigned                                                 M
*****************************************************************************/
void InptPrsrMarkToBeAssigned(ParseTree *Root)
{
    if (Root == NULL)
	return;

    if (IP_IS_FUNCTION(Root -> NodeKind)) {	       /* All the functions. */
	InptPrsrMarkToBeAssigned(Root -> Right);
	return;
    }

    switch (Root -> NodeKind) {
	case IP_TKN_DIV:
	case IP_TKN_MINUS:
	case IP_TKN_MULT:
	case IP_TKN_PLUS:
	case IP_TKN_POWER:

	case IP_TKN_COMMA:
	case IP_TKN_COLON:
	case IP_TKN_EQUAL:
	case IP_TKN_CMP_EQUAL:
	case IP_TKN_CMP_NOTEQUAL:
	case IP_TKN_CMP_LSEQUAL:
	case IP_TKN_CMP_GTEQUAL:
	case IP_TKN_CMP_LESS:
	case IP_TKN_CMP_GREAT:
	case IP_TKN_BOOL_OR:
	case IP_TKN_BOOL_AND:
	    InptPrsrMarkToBeAssigned(Root -> Right);
	    InptPrsrMarkToBeAssigned(Root -> Left);
	    return;

	case IP_TKN_UNARMINUS:
	case IP_TKN_BOOL_NOT:
	    InptPrsrMarkToBeAssigned(Root -> Right);
	    return;

	case IP_TKN_NUMBER:
	case IP_TKN_STRING:
	    return;

	case IP_TKN_PARAMETER:
	    if (IP_IS_UNDEF_OBJ(Root -> PObj))
		SET_TO_BE_ASSIGN_OBJ(Root -> PObj);
            return;

	case IP_TKN_START:
	    return;

	default:
	    IRIT_FATAL_ERROR("InptPrsrMarkToBeAssigned: Undefined ParseTree type, exit");
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Creates an OBJECT LIST object out of all parameters.                       M
*                                                                            *
* PARAMETERS:                                                                M
*   PObjParams:     To insert into one list object.                          M
*                                                                            *
* RETURN VALUE:                                                              M
*   IPObjectStruct *:  A list object with all the parameters, or NULL if     M
*		       error.						     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalGenObjectList                                                    M
*****************************************************************************/
IPObjectStruct *InptEvalGenObjectList(ParseTree *PObjParams)
{
    int i, NumOfParams;
    ParseTree *Param;
    IPObjectStruct *PObj;

    NumOfParams = InptEvalCountNumParameters(PObjParams);

    PObj = IPGenLISTObject(NULL);

    for (i = 0; i < NumOfParams; i++) {
	if ((Param = InptPrsrEvalTree(InptEvalFetchParameter(PObjParams, i,
							     NumOfParams),
				      IP_EVAL_BASE_LEVEL + 1)) == NULL) {
	    IPFreeObject(PObj);
	    return NULL;
        }

	if (IP_IS_UNDEF_OBJ(Param -> PObj)) {
	    IPGlblEvalError = IE_ERR_IP_OBJ_UNDEFINED;
	    strcpy(IPGlblCharData, IP_GET_OBJ_NAME(Param -> PObj));
	    IPListObjectInsert(PObj, i, NULL);
	    IPFreeObject(PObj);
	    return NULL;
	}

	IPListObjectInsert(PObj, i, Param -> PObj);

	/* Must put NULL every time as we might fail and free this object. */
	IPListObjectInsert(PObj, i + 1, NULL);
    }

    return PObj;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Creates a Control Point Object out of all parameters.			     M
*                                                                            *
* PARAMETERS:                                                                M
*   PObjParams:    To create a control pointwith.                            M
*                                                                            *
* RETURN VALUE:                                                              M
*   IPObjectStruct *:   A control point object, or NULL if error.            M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalCtlPtFromParams                                                  M
*****************************************************************************/
IPObjectStruct *InptEvalCtlPtFromParams(ParseTree *PObjParams)
{
    int i, NumPts, NumOfParams, PtType,
	CoordCount = 0;
    ParseTree *Param;
    IPObjectStruct *PObj;

    NumOfParams = InptEvalCountNumParameters(PObjParams);

    PObj = IPAllocObject("", IP_OBJ_CTLPT, NULL);

    for (i = 0; i < NumOfParams; i++) {
	if ((Param = InptPrsrEvalTree(InptEvalFetchParameter(PObjParams, i,
							     NumOfParams),
				      IP_EVAL_BASE_LEVEL + 1)) == NULL) {
	    IPFreeObject(PObj);
	    return NULL;
        }
        if (!IP_IS_NUM_OBJ(Param -> PObj)) {
	    IPGlblEvalError = IE_ERR_TYPE_MISMATCH;
	    strcpy(IPGlblCharData, IRIT_EXP_STR("Numeric data expected"));
	    IPFreeObject(PObj);
	    return NULL;
        }

	if (i == 0) {
	    PtType = PObj -> U.CtlPt.PtType =
	        (CagdPointType) ((int) Param -> PObj -> U.R);
	    switch (PtType) {
		case CAGD_PT_E1_TYPE:
		case CAGD_PT_E2_TYPE:
		case CAGD_PT_E3_TYPE:
		case CAGD_PT_E4_TYPE:
		case CAGD_PT_E5_TYPE:
		case CAGD_PT_E6_TYPE:
		case CAGD_PT_E7_TYPE:
		case CAGD_PT_E8_TYPE:
		case CAGD_PT_E9_TYPE:
		    NumPts = CAGD_NUM_OF_PT_COORD(PtType);
		    CoordCount = 1;
		    break;
		case CAGD_PT_P1_TYPE:
		case CAGD_PT_P2_TYPE:
		case CAGD_PT_P3_TYPE:
		case CAGD_PT_P4_TYPE:
		case CAGD_PT_P5_TYPE:
		case CAGD_PT_P6_TYPE:
		case CAGD_PT_P7_TYPE:
		case CAGD_PT_P8_TYPE:
		case CAGD_PT_P9_TYPE:
		    NumPts = CAGD_NUM_OF_PT_COORD(PtType) + 1;
		    CoordCount = 0;
		    break;
		default:
		    IPGlblEvalError = IE_ERR_TYPE_MISMATCH;
		    strcpy(IPGlblCharData,
			   IRIT_EXP_STR("E{1-9} or P{1-9} point type expected"));
		    IPFreeObject(PObj);
		    return NULL;
	    }
	    if (NumOfParams - 1 != NumPts) {
		IPGlblEvalError = IE_ERR_NUM_PRM_MISMATCH;
		sprintf(IPGlblCharData,
			IRIT_EXP_STR("%d expected in function \"ctlpt\""),
			NumPts);
		IPFreeObject(PObj);
		return NULL;
	    }
	}
        else
	    PObj -> U.CtlPt.Coords[CoordCount++] = Param -> PObj -> U.R;
    }

    return PObj;
}

/*****************************************************************************
* DESCRIPTION:                                                               *
* Fetches the i'th expression out of a tree represent n expressions          *
* (0 <= i < n) separated by colon. Similar to InptEvalFetchParameter rtn.    *
*                                                                            *
* PARAMETERS:                                                                *
*   Root:      To fetch an expression from.                                  *
*   i:         The expression to fetch.                                      *
*   n:         Total number of expressions.                                  *
*                                                                            *
* RETURN VALUE:                                                              *
*   ParseTree *:   Fetched expression.                                       *
*****************************************************************************/
static ParseTree *InptEvalFetchExpression(ParseTree *Root, int i, int n)
{
    int j;

    for (j = 0; j < i; j++)
	Root = Root -> Right;

    if (i == n - 1)
        return Root;
    else
	return Root -> Left;
}

/*****************************************************************************
* DESCRIPTION:                                                               *
* Count the number of expressions separated by a COLON that are given in the *
* tree ROOT. This routine is similar to InptEvalCountNumParameters.          *
*                                                                            *
* PARAMETERS:                                                                *
*   Root:      To count number of expressions.                               *
*                                                                            *
* RETURN VALUE:                                                              *
*   int:       Number of expressions found.                                  *
*****************************************************************************/
static int InptEvalCountNumExpressions(ParseTree *Root)
{
    int i = 1;

    while (Root -> NodeKind == IP_TKN_COLON) {
	i++;
	Root = Root -> Right;
    }
    return i;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Handles a user defined function or procedure.		  	             M
*   A user defined function or proecdure is of the sepcial form:	     M
*									     M
* FuncName = {function | procedure}(Param1, Param2, ... , ParamN):	     V
*	LocalVar1: LocalVar2: ... LocalVarN:				     V
*	BodyExpr1: BodyExpr2: ... BodYExprN;				     V
*									     M
* This special form is decomposed into the following sections:		     M
* 1. Parameter list as a list of IPObjectStructs.			     M
* 2. Local variable list as a list of IPObjectStructs.			     M
* 3. Body expression list as a Parsing tree.				     M
*									     M
* Defined function is saved in the global UserDefinedFuncList list.	     M
*                                                                            *
* PARAMETERS:                                                                M
*   FuncDef:   Parse tree of user defined function.                          M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalDefineFunc                                                       M
*****************************************************************************/
void InptEvalDefineFunc(ParseTree *FuncDef)
{
    int NewFunc;
    char
	*Name = IP_GET_OBJ_NAME(FuncDef -> Left -> Left -> PObj);
    ParseTree *Body, *PTmp;
    UserDefinedFuncDefType *UserFunc;
    IPObjectStruct *PObjTail, *PObj, *PObjTmp;

    for (UserFunc = UserDefinedFuncList;
	 UserFunc != NULL;
	 UserFunc = UserFunc -> Pnext) {
	if (strcmp(UserFunc -> FuncName, Name) == 0) {
	    InptEvalDeleteFunc(UserFunc, FALSE);
	    break;
	}
    }
    if (UserFunc == NULL) {
	UserFunc = (UserDefinedFuncDefType *)
	    IritMalloc(sizeof(UserDefinedFuncDefType));
	UserFunc -> Params = UserFunc -> LocalVars = NULL;
	UserFunc -> Body = NULL;
	UserFunc -> NumParams = 0;
	NewFunc = TRUE;
    }
    else {
	InptEvalDeleteFunc(UserFunc, FALSE);
	NewFunc = FALSE;
    }

    /* Mark it as a function or procedure. */
    UserFunc -> IsFunction =
	FuncDef -> Left -> Right -> NodeKind == IP_USERFUNCDEF;

    /* Get the function name. */
    PTmp = FuncDef -> Left -> Left;
    strncpy(UserFunc -> FuncName, Name, IP_FUNC_NAME_LEN - 1);
    if (PTmp -> PObj -> ObjType == IP_OBJ_UNDEF) {
	/* Free it since no such object exists. */
	IPFreeObject(PTmp -> PObj);
	PTmp -> PObj = NULL;
    }

    /* Remove the object with function name and the return variable if they  */
    /* were undefined and were created because of the parsing of function.   */
    if ((PObj = IritDBGetObjByName(Name)) != NULL &&
	PObj -> ObjType == IP_OBJ_UNDEF)
	IritDBDeleteObject(PObj, TRUE);
    if ((PObj = IritDBGetObjByName("RETURN")) != NULL &&
	PObj -> ObjType == IP_OBJ_UNDEF)
	IritDBDeleteObject(PObj, TRUE);

    /* Save the list of parameters. */
    for (PTmp = FuncDef -> Left -> Right -> Right, PObjTail = NULL;
	 PTmp != NULL && PTmp -> NodeKind == IP_TKN_COMMA;
	 PTmp = PTmp -> Right) {
	if (PTmp -> Left -> NodeKind == IP_TKN_PARAMETER) {
	    Name = IP_GET_OBJ_NAME(PTmp -> Left -> PObj);

	    /* Make sure we do not have duplicated names in param. list. */
	    for (PObjTmp = UserFunc -> Params;
		 PObjTmp != NULL;
		 PObjTmp = PObjTmp -> Pnext) {
		if (strcmp(Name, IP_GET_OBJ_NAME(PObjTmp)) == 0) {
		    IPGlblEvalError = IE_ERR_IP_USERFUNC_DUP_VAR;
		    sprintf(IPGlblCharData,
			    IRIT_EXP_STR("Func \"%s\", Variable \"%s\""),
			    UserFunc -> FuncName, Name);
		    InptEvalDeleteFunc(UserFunc, TRUE);
		    return;
		}
	    }

	    /* Create a new object with same name but undefined type. */
	    if (UserFunc -> Params == NULL)
		UserFunc -> Params = PObjTail = 
		    IPAllocObject(Name, IP_OBJ_UNDEF, NULL);
	    else {
		PObjTail -> Pnext = IPAllocObject(Name, IP_OBJ_UNDEF, NULL);
		PObjTail = PObjTail -> Pnext;
	    }

	    /* Make sure there is no undefined object by that name in global */
	    /* list from the parsing stage. If so - remove it.		     */
	    if ((PObj = IritDBGetObjByName(Name)) != NULL &&
		PObj -> ObjType == IP_OBJ_UNDEF)
		IritDBDeleteObject(PObj, TRUE);
	}
	UserFunc -> NumParams++;
    }

    if (PTmp != NULL && PTmp  -> NodeKind == IP_TKN_PARAMETER) {
	Name = IP_GET_OBJ_NAME(PTmp -> PObj);

	/* Make sure we do not have duplicated names in param. list. */
	for (PObjTmp = UserFunc -> Params;
	     PObjTmp != NULL;
	     PObjTmp = PObjTmp -> Pnext) {
	    if (strcmp(Name, IP_GET_OBJ_NAME(PObjTmp)) == 0) {
		IPGlblEvalError = IE_ERR_IP_USERFUNC_DUP_VAR;
		sprintf(IPGlblCharData,
			IRIT_EXP_STR("Func \"%s\", Variable \"%s\""),
			UserFunc -> FuncName, Name);
		InptEvalDeleteFunc(UserFunc, TRUE);
		return;
	    }
	}

	/* Create a new object with same name but undefined type. */
	if (UserFunc -> Params == NULL)
	    UserFunc -> Params = PObjTail = 
		IPAllocObject(Name, IP_OBJ_UNDEF, NULL);
	else {
	    PObjTail -> Pnext = IPAllocObject(Name, IP_OBJ_UNDEF, NULL);
	    PObjTail = PObjTail -> Pnext;
	}

	/* Make sure there is no undefined object by that name in global     */
	/* list from the parsing stage. If so - remove it.		     */
	if ((PObj = IritDBGetObjByName(Name)) != NULL &&
	    PObj -> ObjType == IP_OBJ_UNDEF)
	    IritDBDeleteObject(PObj, TRUE);

	UserFunc -> NumParams++;
    }

    if (UserFunc -> NumParams > IP_USERFUNC_MAX_PARAM) {
	IPGlblEvalError = IE_ERR_IP_USERFUNC_TOO_MANY_PRMS;
	sprintf(IPGlblCharData,
		IRIT_EXP_STR("Func \"%s\", has %d parameters (Max %d)"),
		UserFunc -> FuncName, UserFunc -> NumParams,
		IP_USERFUNC_MAX_PARAM);
	InptEvalDeleteFunc(UserFunc, TRUE);
	return;
    }

    /* Allocate a "return" variable. */
    UserFunc -> LocalVars = IPAllocObject("RETURN", IP_OBJ_UNDEF, NULL);

    /* Isolate the body of the function while saving the list of local vars. */
    for (Body = FuncDef -> Right, PTmp = FuncDef;
	 Body -> NodeKind == IP_TKN_COLON &&
	     Body -> Left -> NodeKind == IP_TKN_PARAMETER;
	 PTmp = Body, Body = Body -> Right) {
	Name = IP_GET_OBJ_NAME(Body -> Left -> PObj);
		
	/* Make sure we do not have duplicated names in local vars list. */
	for (PObjTmp = UserFunc -> Params;
	     PObjTmp != NULL;
	     PObjTmp = PObjTmp -> Pnext) {
	    if (strcmp(Name, IP_GET_OBJ_NAME(PObjTmp)) == 0) {
		IPGlblEvalError = IE_ERR_IP_USERFUNC_DUP_VAR;
		sprintf(IPGlblCharData,
			IRIT_EXP_STR("Func \"%s\", Variable \"%s\""),
			UserFunc -> FuncName, Name);
		InptEvalDeleteFunc(UserFunc, TRUE);
		return;
	    }
	}
	for (PObjTmp = UserFunc -> LocalVars;
	     PObjTmp != NULL;
	     PObjTmp = PObjTmp -> Pnext) {
	    if (strcmp(Name, IP_GET_OBJ_NAME(PObjTmp)) == 0) {
		IPGlblEvalError = IE_ERR_IP_USERFUNC_DUP_VAR;
		sprintf(IPGlblCharData,
			IRIT_EXP_STR("Func \"%s\", Variable \"%s\""),
			UserFunc -> FuncName, Name);
		InptEvalDeleteFunc(UserFunc, TRUE);
		return;
	    }
	}

	/* We found a local variable decl. Copy it to local variable list.   */
	/* Create a new object with same name but undefined type.            */
	UserFunc -> LocalVars =
	    IPAllocObject(Name, IP_OBJ_UNDEF, UserFunc -> LocalVars);

	/* Make sure there is no undefined object by that name in global     */
	/* list from the parsing stage. If so - remove it.		     */
	if ((PObj = IritDBGetObjByName(Name)) != NULL &&
	    PObj -> ObjType == IP_OBJ_UNDEF)
	    IritDBDeleteObject(PObj, TRUE);
    }

    /* Disconnect body of the function and save it in function definition.  */
    PTmp -> Right = NULL;
    UserFunc -> Body = Body;

    InptPrsrMarkToBeAssigned(Body);
    if (InptPrsrTypeCheck(Body, 0) != ERROR_EXPR) {
	if (NewFunc) {
	    IPObjectStruct *PObjFuncNameList;

	    UserFunc -> Pnext = UserDefinedFuncList;
	    UserDefinedFuncList = UserFunc;

	    /* Append name of the function into global user defined funcs. */
	    if ((PObjFuncNameList =
		                 IritDBGetObjByName("USR_FN_LIST")) != NULL) {
		IPObjectStruct
		    *PObj = IPGenSTRObject(UserFunc -> FuncName);

	        SnocList(PObj, PObjFuncNameList);
	    }
	}
	InptEvalWarningNewFunc(UserFunc);
    }
    else
	InptEvalDeleteFunc(UserFunc, TRUE);
}

/*****************************************************************************
* DESCRIPTION:                                                               *
*   Check the function just defined for some special cases that deserve a    *
* warning message.                                                           *
*                                                                            *
* PARAMETERS:                                                                *
*   UserFunc:   Function just define to check.                               *
*                                                                            *
* RETURN VALUE:                                                              *
*   void                                                                     *
*****************************************************************************/
static void InptEvalWarningNewFunc(UserDefinedFuncDefType *UserFunc)
{
    char *p;

    if ((p = InptEvalNewFuncHasFree(UserFunc, UserFunc -> Body)) != NULL)
        IRIT_NON_FATAL_ERROR2("Free of local variable \"%s\" may result in unpredictable results.", p);
}

/*****************************************************************************
* DESCRIPTION:                                                               *
*   Scans the given function body for "free(x);" type of expressions and     *
* return NULL if none.  a pointer to a string holding the freed object name  *
* (x) is return if detected.						     *
*                                                                            *
* PARAMETERS:                                                                *
*   UserFunc:    Function just define to check.                              *
*   FuncBody:    New function body to examine for a free function call.      *
*                                                                            *
* RETURN VALUE:                                                              *
*   char *:                                                                  *
*****************************************************************************/
static char *InptEvalNewFuncHasFree(UserDefinedFuncDefType *UserFunc,
				    ParseTree *FuncBody)
{
    char *p;

    if (!FuncBody)
	return NULL;

    switch (FuncBody -> NodeKind) {
	case IP_FREE:
	    if (FuncBody -> Right != NULL &&
		FuncBody -> Right -> PObj != NULL) {
	        IPObjectStruct *PObj;

	        p = IP_GET_OBJ_NAME(FuncBody -> Right -> PObj);

	        /* Lets see if this variable is a local variable. */
	        for (PObj = UserFunc -> Params;
		     PObj != NULL;
		     PObj = PObj -> Pnext)
		    if (strcmp(p, IP_GET_OBJ_NAME(PObj)) == 0)
		        return p;
	        for (PObj = UserFunc -> LocalVars;
		     PObj != NULL;
		     PObj = PObj -> Pnext)
		    if (strcmp(p, IP_GET_OBJ_NAME(PObj)) == 0)
		        return p;
		return NULL;
	    }
	    else
		return "Unknown";
	    break;
	case IP_TKN_COMMA:
	case IP_TKN_COLON:
	    if ((p = InptEvalNewFuncHasFree(UserFunc,
					    FuncBody -> Right)) != NULL)
		return p;
	    return InptEvalNewFuncHasFree(UserFunc, FuncBody -> Left);
	    break;
	default:
	    return NULL;
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               *
* Deletes/clears a user defined function structure.			     *
*                                                                            *
* PARAMETERS:                                                                *
*   UserFunc:    To remove from global list.                                 *
*   DeleteSelf:  If TRUE, free UserFunc as well.                             *
*                                                                            *
* RETURN VALUE:                                                              *
*   void                                                                     *
*****************************************************************************/
static void InptEvalDeleteFunc(UserDefinedFuncDefType *UserFunc,
			       int DeleteSelf)
{
    if (UserFunc -> Params != NULL)
	IPFreeObjectList(UserFunc -> Params);
    if (UserFunc -> LocalVars != NULL)
	IPFreeObjectList(UserFunc -> LocalVars);
    if (UserFunc -> Body != NULL)
	InptPrsrFreeTree(UserFunc -> Body);

    if (DeleteSelf) {
	if (UserFunc == UserDefinedFuncList)
	    UserDefinedFuncList = UserDefinedFuncList -> Pnext;
	else if (UserDefinedFuncList != NULL) {
	    UserDefinedFuncDefType *TempFunc;

	    for (TempFunc = UserDefinedFuncList;
		 TempFunc -> Pnext != UserFunc && TempFunc -> Pnext != NULL;
		 TempFunc = TempFunc -> Pnext);
	    if (TempFunc && TempFunc -> Pnext == UserFunc)
		TempFunc -> Pnext = TempFunc -> Pnext -> Pnext;
	}
	IritFree(UserFunc);
    }
    else {
	UserFunc -> Params = UserFunc -> LocalVars = NULL;
	UserFunc -> Body = NULL;
	UserFunc -> NumParams = 0;
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Frees a user defined function - delete it from global active list of user  M
* defined functions.							     M
*                                                                            *
* PARAMETERS:                                                                M
*   FuncName:    Name of function to free.  Must be a user defined function. M
*		 If NULL or zero length, it frees all functions defined in   M
*		 the global variable USR_FN_LIST.			     M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalFreeFunc                                                         M
*****************************************************************************/
void InptEvalFreeFunc(const char *FuncName)
{
    int i;
    UserDefinedFuncDefType *UserFunc;
    IPObjectStruct *PObjFuncNameList, *PTmp;

    if (IRT_STR_NULL_ZERO_LEN(FuncName)) {
        if ((PObjFuncNameList = IritDBGetObjByName("USR_FN_LIST")) != NULL &&
	    IP_IS_OLST_OBJ(PObjFuncNameList)) {
	    for (i = 0;
		 (PTmp = IPListObjectGet(PObjFuncNameList, i)) != NULL;
		 i++) {
		if (IP_IS_STR_OBJ(PTmp))
		    InptEvalFreeFunc(PTmp -> U.Str);
	    }
	}
    }
    else {
        for (UserFunc = UserDefinedFuncList;
	     UserFunc != NULL;
	     UserFunc = UserFunc -> Pnext) {
	    if (strcmp(UserFunc -> FuncName, FuncName) == 0) {
	        InptEvalDeleteFunc(UserFunc, TRUE);
		return;
	    }
	}
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
*   Deletes/clears a user defined function structure.			     M
*                                                                            *
* PARAMETERS:                                                                M
*   None                                                                     M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalDeleteAllFuncs                                                   M
*****************************************************************************/
void InptEvalDeleteAllFuncs(void)
{
    while (UserDefinedFuncList != NULL)
	InptEvalDeleteFunc(UserDefinedFuncList, TRUE);
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Sets the debug level of user function calls.				     M
*                                                                            *
* PARAMETERS:                                                                M
*   DebugFuncLevel:  Level of debugging user defined functions.              M
*                                                                            *
* RETURN VALUE:                                                              M
*   int:  Old value.                                                         M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrDebugFuncLevel                                                   M
*****************************************************************************/
int InptPrsrDebugFuncLevel(int DebugFuncLevel)
{
    int OldVal = GlblDebugFuncLevel;

    GlblDebugFuncLevel = DebugFuncLevel;

    return OldVal;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Invokes the evaluation of a user function.				     M
*   The following steps are performed:					     M
* 1. A copy is made of parameter variables and local variables.		     M
* 2. Binding of given parameters to function parameters.		     M
* 3. The local variables and parameters are added to global variable list.   M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:         Parse tree of user defined function.                       M
*   InputParams:  Parameters of the function.                                M
*                                                                            *
* RETURN VALUE:                                                              M
*   ParseTree *:  Evaluated result.                                          M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalUserFunc                                                         M
*****************************************************************************/
ParseTree *InptEvalUserFunc(ParseTree *Root, ParseTree *InputParams[])
{
    int i;
    UserDefinedFuncDefType
	*UserFunc = Root -> UserFunc;
    IPObjectStruct *PObj,
	*RetVal = NULL,
	*Params = IPCopyObjectList(UserFunc -> Params, TRUE),
	*LocalVars = IPCopyObjectList(UserFunc -> LocalVars, TRUE),
        *LocalVarsLast = IPGetLastObj(LocalVars);
    ParseTree
	*Body = InptPrsrCopyTree(UserFunc -> Body);

    if (GlblDebugFuncLevel > 0) {
	IRIT_WNDW_FPRINTF2("***** DEBUG FUNC: invoking \"%s\"\n",
			   UserFunc -> FuncName);
    }

    if (LocalVars) {
	/* Rebind local variables. */
	for (PObj = LocalVars, i = 0; PObj != NULL; PObj = PObj -> Pnext) {
	    PObj -> Count++;
	    RebindVariable(Body, PObj);
	}

	/* Push the local variables into the DB. */
	IritDBPush(LocalVars);
    }

    if (Params) {
	/* Copy the parameter data into the parameters and rebind. */
	for (PObj = Params, i = 0; PObj != NULL; PObj = PObj -> Pnext, i++) {
	    if (InputParams[i] -> PObj -> ObjType == IP_OBJ_UNDEF) {
		IPGlblEvalError = IE_ERR_IP_OBJ_UNDEFINED;
		sprintf(IPGlblCharData,
			IRIT_EXP_STR("%s's parameter %d (%s)."),
			UserFunc -> FuncName, i + 1,
			IP_GET_OBJ_NAME(PObj));
		return NULL;
	    }
	    IPCopyObject(PObj, InputParams[i] -> PObj, FALSE);
	    RebindVariable(Body, PObj);

	    if (GlblDebugFuncLevel > 2) {
		IRIT_WNDW_FPRINTF3("***** DEBUG FUNC %s: parameter %d =\n",
				   UserFunc -> FuncName, i);
		PrintIritObject(PObj);	    
	    }
	}

	/* Push the parameters into the DB. */
	IritDBPush(Params);
    }

    if (GlblDebugFuncLevel > 4) {
	IRIT_WNDW_FPRINTF2("***** DEBUG FUNC %s: global variable list =\n",
			   UserFunc -> FuncName);
	IritDBPrintAllObjs();	    
    }

    /* Invoke the body of the function/procedure, saving current var. state. */
    InptPrsrEvalTree(Body, IP_EVAL_BASE_LEVEL);

    if (strcmp(IP_GET_OBJ_NAME(LocalVarsLast), "RETURN") != 0)
	IRIT_FATAL_ERROR("Must have return value as last local\n");
    if (UserFunc -> IsFunction) {
	if (LocalVarsLast -> ObjType == IP_OBJ_UNDEF) {
	    IPGlblEvalError = IE_ERR_USER_FUNC_NO_RETVAL;
	    strcpy(IPGlblCharData, UserFunc -> FuncName);
	}
	else {
	    RetVal = IPCopyObject(NULL, LocalVarsLast, FALSE);

	    if (GlblDebugFuncLevel > 2) {
		IRIT_WNDW_FPRINTF2("***** DEBUG FUNC %s: return value =\n",
				   UserFunc -> FuncName);
		PrintIritObject(RetVal);	    
	    }
	}
    }
    else {
	if (GlblDebugFuncLevel > 0) {
	    IRIT_WNDW_FPRINTF2("***** DEBUG FUNC: leaving \"%s\"\n",
			       UserFunc -> FuncName);
	}
    }

    InptPrsrFreeTree(Body);

    if (Params)
	IritDBPop(FALSE);

    if (LocalVars != NULL)
	IritDBPop(TRUE);

    if (RetVal == NULL)
	return NULL;
    else {
	Root -> PObj = RetVal;
	Root -> PObj -> Count++;
	return Root;
    }
}
