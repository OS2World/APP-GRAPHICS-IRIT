/*****************************************************************************
*   "Irit" - the 3d (not only polygonal) solid modeller.		     *
*									     *
* Written by:  Gershon Elber				Ver 0.2, Mar. 1990   *
******************************************************************************
* (C) Gershon Elber, Technion, Israel Institute of Technology                *
******************************************************************************
*   Module to evaluate the binary tree generated by the InptPrsr module.     *
*   All the objects are handled the same but the numerical one, which is     *
* moved as a IrtRType and not as an object (only internally within this	     *
* module) as it is frequently used and consumes much less memory this way.   *
*****************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <string.h>
#include "program.h"
#include "allocate.h"
#include "attribut.h"
#include "obj_dpnd.h"
#include "ctrl-brk.h"
#include "dosintr.h"
#include "freeform.h"
#include "geom_lib.h"
#include "inptprsg.h"
#include "inptprsl.h"
#include "objects.h"
#include "overload.h"
#include "grap_lib.h"

/* #define IRIT_PRSR_DEBUG_DPNDNCY */
#ifdef DEBUG
IRIT_SET_DEBUG_PARAMETER(_DebugIritPrsrDepndncy, FALSE);
IRIT_SET_DEBUG_PARAMETER(_DebugIritPrsrDispNesting, FALSE);
#endif /* DEBUG */

IRIT_GLOBAL_DATA InptPrsrEvalErrType
    IPGlblEvalError = IPE_NO_ERR;		 /* Global used by EvalTree. */

static void LocalPrintTree(const ParseTree *Root,
			   int Level,
			   char *Str,
			   int StrLen);
static void InptPrsrPropagateDependencyObjects(IPObjectStruct *PObj,
					       ParseTree *Root);
static void InptPrsrPropagateUpdatedObjects(IPObjectStruct *PObj,
					    int UpdateIndex);

/*****************************************************************************
* DESCRIPTION:                                                               M
* Returns a string representing the given type.				     M
*                                                                            *
* PARAMETERS:                                                                M
*   Type:     Type to get a string representation for.                       M
*                                                                            *
* RETURN VALUE:                                                              M
*   char *:   A string describing type Type.                                 M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrTypeToStr                                                        M
*****************************************************************************/
char *InptPrsrTypeToStr(IritExprType Type)
{
    switch (Type) {
	case POLY_EXPR:
	    return "Poly";
	case NUMERIC_EXPR:
	    return "Numeric";
	case POINT_EXPR:
	    return "Point";
	case VECTOR_EXPR:
	    return "Vector";
	case PLANE_EXPR:
	    return "Plane";
	case CTLPT_EXPR:
	    return "Control Point";
	case MATRIX_EXPR:
	    return "Matrix";
	case STRING_EXPR:
	    return "String";
	case OLST_EXPR:
	    return "List Object";
	case CURVE_EXPR:
	    return "Curve";
	case SURFACE_EXPR:
	    return "Surface";
	case TRIMSRF_EXPR:
	    return "Trimmed Surface";
	case TRIVAR_EXPR:
	    return "Trivar";
	case TRISRF_EXPR:
	    return "Triangular Srf";
	default:
	    return "Undefined/Mixed";
    }

}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Counts the number of parameters in Root. Parameters are defined as         M
* subtrees separated by commas, i.e.: the infix form 1, 2, 3, 4 is 	     M
* represented as [1, [2, [3, 4]]] in the tree supplied to this function and  M
* 4 (number of parameters) is returned.					     M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:      To count the number of its parameters.                        M
*                                                                            *
* RETURN VALUE:                                                              M
*   int:       Number of parameters encountered.                             M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalCountNumParameters                                               M
*****************************************************************************/
int InptEvalCountNumParameters(ParseTree *Root)
{
    int i = 1;

    if (Root == NULL)
	return 0;

    while (Root -> NodeKind == IP_TKN_COMMA) {
	i++;
	Root = Root -> Right;
    }
    return i;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Fetches the i'th paramter out of a tree represent n parameters             M
* (0 <= i < n). See InptEvalCountNumParameters for more description of	     M
* structure.								     M
* Note it is assumed the tree HAS n parameters and 0<=i<n (No input error).  M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:     To fetch its i'th parameter.                                   M
*   i:        The parameter wanted.                                          M
*   n:        Total number of parameters in Root.                            M
*                                                                            *
* RETURN VALUE:                                                              M
*   ParseTree *:    The requested parameter.                                 M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalFetchParameter                                                   M
*****************************************************************************/
ParseTree *InptEvalFetchParameter(ParseTree *Root, int i, int n)
{
    int j;

    for (j = 0; j < i; j++)
	Root = Root -> Right;

    if (i == n - 1)
	return Root;
    else
	return Root -> Left;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Fetches the parameters of a function from the parsed tree.		     M
* Returns TRUE iff fetching was succesfull.				     M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:          Where the parameters should be searched for.              M
*   FuncTable:     The table's entry of the function we deal with.           M
*   NumParams:     Number of parameters of function.                         M
*   Level:         Level of recursion. To identify top levels.               M
*   Params:        Where to put the parameters as ParseTree.                 M
*   ParamPtrs:     And as pointers to IrtRType/IrtPtType/IrtVecType etc.     M
*                                                                            *
* RETURN VALUE:                                                              M
*   int:           Number of matches or zero if error. 			     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalFetchParameters                                                  M
*****************************************************************************/
int InptEvalFetchParameters(ParseTree *Root,
			    FuncTableType *FuncTable,
			    int NumParams,
			    int Level,
			    ParseTree *Params[],
			    VoidPtr ParamPtrs[])
{
    int i;

    Level++;
    for (i = 0; i < NumParams; i++) {
	ParseTree *Param;

	if ((Param = InptEvalFetchParameter(Root -> Right, i, NumParams))
								== NULL ||
	    (Params[i] = InptPrsrEvalTree(Param, Level)) == NULL)
	    return i;

	if (FuncTable != NULL) {
	    IritExprType
		ParamObjExpr = Params[i] -> PObj ?
		    InptPrsrObjType2Expr(Root, Params[i] -> PObj) : NO_EXPR;

	    if ((ParamObjExpr & FuncTable -> ParamObjType[i]) == 0) {
		IRIT_NON_FATAL_ERROR5(
			"Eval Error: Parameter type mismatch - Func %s, parameter %d\n\texpected \"%s\", found \"%s\".",
			FuncTable -> FuncName, i + 1,
			InptPrsrTypeToStr(FuncTable -> ParamObjType[i]),
			InptPrsrTypeToStr(ParamObjExpr));
		return 0;
	    }
	    
	    switch (FuncTable -> ParamObjType[i]) {
		case NUMERIC_EXPR:
		    ParamPtrs[i] = &Params[i] -> PObj -> U.R;
		    break;
		case POINT_EXPR | VECTOR_EXPR:/* Assuming point/vector same. */
		case POINT_EXPR:
		case VECTOR_EXPR:
		    ParamPtrs[i] = Params[i] -> PObj -> U.Vec;
		    break;
		case PLANE_EXPR:
		    ParamPtrs[i] = Params[i] -> PObj -> U.Plane;
		    break;
		case STRING_EXPR:
		    ParamPtrs[i] = Params[i] -> PObj -> U.Str;
		    break;
		default:
		    ParamPtrs[i] = Params[i] -> PObj;
		    break;
	    }
	}
    }

    return i;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Tests number of parameters and type of them against what is defined in the M
* global tables Num/Obj/GenFuncTable. return TRUE if mismatch was detected.  M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:     The function entry node.                                       M
*                                                                            *
* RETURN VALUE:                                                              M
*   int:      TRUE if a mismatch wasdetected, FALSE of o.k.		     N
*                                                                            *
* KEYWORDS:                                                                  M
*   IritEvalFuncParamMismatch                                                M
*****************************************************************************/
int IritEvalFuncParamMismatch(ParseTree *Root)
{
    int FuncOffset, Count,
	i = Root -> NodeKind / 100;
    FuncTableType *FuncTable;

    switch (i * 100) {
	case IP_NUM_FUNC:	       /* Numeric (real returned) functions. */
	    FuncOffset = Root -> NodeKind - IP_NUM_FUNC_OFFSET;
	    FuncTable = (FuncTableType *) NumFuncTable;
	    break;
	case IP_OBJ_FUNC1:		     /* Object (returned) functions. */
	case IP_OBJ_FUNC2:		     /* Object (returned) functions. */
	case IP_OBJ_FUNC3:		     /* Object (returned) functions. */
	case IP_OBJ_FUNC4:		     /* Object (returned) functions. */
	    FuncOffset = Root -> NodeKind - IP_OBJ_FUNC_OFFSET;
	    FuncTable = (FuncTableType *) ObjFuncTable;
	    break;
	case IP_GEN_FUNC:
	    FuncOffset = Root -> NodeKind - IP_GEN_FUNC_OFFSET;
	    FuncTable = (FuncTableType *) GenFuncTable;
	    break;
	default:
	    IPGlblEvalError = IE_ERR_FATAL_ERROR;
	    UpdateCharError(IRIT_EXP_STR("Undefined function - "),
			    Root -> NodeKind, Root);
	    return TRUE;
    }

    Count = InptEvalCountNumParameters(Root -> Right);

    if (FuncTable[FuncOffset].NumOfParam == IP_ANY_PARAM_NUM) {
	for (i = 0; i < Count; i++) {
	    IritExprType EType;

	    /* Special cases - FOR and IF - top level considerations. */
	    if ((Root -> NodeKind == IP_FOR && i == 3) ||
		(Root -> NodeKind == IP_IF && i > 0))
		EType = InptPrsrTypeCheck(InptEvalFetchParameter(Root -> Right,
								 i, Count), 0);
	    else
		EType = InptPrsrTypeCheck(InptEvalFetchParameter(Root -> Right,
								 i, Count), 1);

	    /* Check only for consistency of input. */
	    if (EType == ERROR_EXPR)
		return TRUE;
	}
	return FALSE;
    }
    else { /* Number of parameter is well known and is in Count. */
	/* See if number of parameters is ok: */
	if (Count != FuncTable[FuncOffset].NumOfParam) {
	    IPGlblEvalError = IE_ERR_NUM_PRM_MISMATCH;
	    sprintf(IPGlblCharData,
		    IRIT_EXP_STR("%d expected in function \"%s\", %d found"),
		    FuncTable[FuncOffset].NumOfParam,
		    FuncTable[FuncOffset].FuncName,
		    Count);
	    return TRUE;
	}

	/* See if type of parameters are consistent: */
	for (i = 0; i < Count; i++) {
	    IritExprType EType;

	    /* Special cases - FORLOOP and IF - top level considerations. */
	    if ((Root -> NodeKind == IP_FOR && i == 3) ||
		(Root -> NodeKind == IP_IF && i > 0))
		EType = InptPrsrTypeCheck(InptEvalFetchParameter(Root -> Right,
								 i, Count), 0);
	    else
		EType = InptPrsrTypeCheck(InptEvalFetchParameter(Root -> Right,
								 i, Count), 1);

	    if (EType == ERROR_EXPR)
		return TRUE;
	    if (FuncTable[FuncOffset].ParamObjType[i] != ANY_EXPR &&
		!(FuncTable[FuncOffset].ParamObjType[i] & EType)) {
		sprintf(IPGlblCharData, IRIT_EXP_STR("Func %s,%sparameter %d"),
			FuncTable[FuncOffset].FuncName,
			IPGlblEvalError == IE_ERR_IP_OBJ_UNDEFINED ?
				    IRIT_EXP_STR(" undefined ") : " ", i + 1);
		IPGlblEvalError = IE_ERR_TYPE_MISMATCH;
		return TRUE;
	    }
	}
	return FALSE;
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Deallocates a parsed tree - release all memory allocated by it.	     M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:      Of tree to release.                                           M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrFreeTree                                                         M
*****************************************************************************/
void InptPrsrFreeTree(ParseTree *Root)
{
    char s[IRIT_LINE_LEN];

    if (!Root)
	return;

    if (IP_IS_FUNCTION(Root -> NodeKind)) {
	if (!IP_IS_NO_PARAM_FUNC(Root -> NodeKind))
	    InptPrsrFreeTree(Root -> Right);
	if (Root -> PObj != NULL) {
	    IPFreeObject(Root -> PObj);
	}
	ExprFree(Root);

	return;
    }

    switch (Root -> NodeKind) {
	case IP_TKN_DIV:
	case IP_TKN_MINUS:
	case IP_TKN_MULT:
	case IP_TKN_PLUS:
	case IP_TKN_POWER:
	    InptPrsrFreeTree(Root -> Right);
	    InptPrsrFreeTree(Root -> Left);
	    if (Root -> PObj != NULL) {
		IPFreeObject(Root -> PObj);
	    }
	    ExprFree(Root);
	    break;

	case IP_TKN_UNARMINUS:
	case IP_TKN_BOOL_NOT:
	    InptPrsrFreeTree(Root -> Right);
	    if (Root -> PObj != NULL) {
		IPFreeObject(Root -> PObj);
	    }
	    ExprFree(Root);
	    break;

	case IP_TKN_COMMA:
	    /* Long lists of objects (polygons!?) could result in deap level */
	    /* of recursion - handle this by iterating through the list.     */
	    while (Root != NULL && Root -> NodeKind == IP_TKN_COMMA) {
	        ParseTree
		    *Right = Root -> Right;

		InptPrsrFreeTree(Root -> Left);
		if (Root -> PObj != NULL) {
		    IPFreeObject(Root -> PObj);
		}
		ExprFree(Root);
		Root = Right;
	    }
	    if (Root != NULL)
	        InptPrsrFreeTree(Root);
	    break;
	case IP_TKN_COLON:
	case IP_TKN_EQUAL:
	case IP_TKN_CMP_EQUAL:
	case IP_TKN_CMP_NOTEQUAL:
	case IP_TKN_CMP_LSEQUAL:
	case IP_TKN_CMP_GTEQUAL:
	case IP_TKN_CMP_LESS:
	case IP_TKN_CMP_GREAT:
	case IP_TKN_BOOL_OR:
	case IP_TKN_BOOL_AND:
  	    InptPrsrFreeTree(Root -> Right);
	    InptPrsrFreeTree(Root -> Left);
	    if (Root -> PObj != NULL) {
		IPFreeObject(Root -> PObj);
	    }
	    ExprFree(Root);
	    break;

	case IP_TKN_PARAMETER:
	    if (Root -> PObj) {
		IPFreeObject(Root -> PObj);
	    }
	    ExprFree(Root);
	    break;

	case IP_TKN_NUMBER:
	case IP_TKN_STRING:
	    if (Root -> PObj) {
		IPFreeObject(Root -> PObj);
	    }
	    ExprFree(Root);
	    break;

	case IP_TKN_START:
	    ExprFree(Root);
	    break;

	case IP_TKN_OPENPARA:
	case IP_TKN_CLOSPARA:
	    ExprFree(Root);
	    break;

	default:
	    /*   We might free partially build (by InptPrsr) tree when error */
	    /* is detected, and such tree may have nodes with                */
	    /* NodeKind >= IP_PRSR_MAX_TOKEN.				     */
	    if (Root -> NodeKind >= IP_PRSR_MAX_TOKEN) {
		ExprFree(Root);
	    }
	    else {
		sprintf(s, IRIT_EXP_STR("%s (%d).\n"),
		    IRIT_EXP_STR("InptPrsrFreeTree: Undefined ParseTree type to free"),
		    Root -> NodeKind);
		IRIT_FATAL_ERROR(s);
	    }
	    break;
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Prints the content of ROOT (using inorder traversal).			     M
* If *Str = NULL prints out, else on given string Str.	   	             M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:      Of tree to print.                                             M
*   Str:       String to write on the inorder of Root, or write out if NULL. M
*   StrLen:    Length of string Str.					     M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrPrintTree                                                        M
*****************************************************************************/
void InptPrsrPrintTree(const ParseTree *Root, char *Str, int StrLen)
{
    if (Str == NULL) {
	IPGlblCharData[0] = 0;			   /* Make the string empty. */
	/* Copy to a local strings and then send out. */
	LocalPrintTree(Root, 0, IPGlblCharData, INPUT_LINE_LEN);
	IRIT_INFO_MSG(IPGlblCharData);			     /* And print... */
    }
    else {
	Str[0] = 0;				   /* Make the string empty. */
	/* Dont print out - copy to Str directly. */
	LocalPrintTree(Root, 0, Str, StrLen);
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               *
* Auxiliary function of InptPrsrPrintTree.				     *
* expression.								     *
*                                                                            *
* PARAMETERS:                                                                *
*   Root:      Of tree to print.                                             *
*   Level:     Of recursion.                                                 *
*   Str:       String to write on the inorder of Root, or write out if NULL. *
*   StrLen:    Length of string Str.					     *
*                                                                            *
* RETURN VALUE:                                                              *
*   void                                                                     *
*****************************************************************************/
static void LocalPrintTree(const ParseTree *Root,
			   int Level,
			   char *Str,
			   int StrLen)
{
#ifndef IRIT_QUIET_STRINGS
    int Len, i,
	CloseFlag = FALSE;

    if (!Root)
	return;
    i = (Root -> NodeKind % IP_PRSR_MAX_TOKEN) / 100;

    if ((Len = (int) strlen(Str)) > StrLen - 100) {	/* Prevent overflow. */
	if (Str[Len - 1] == '.')
	    return;			 /* "..." was allready concatenated. */
	else {
	    strcat(Str, "...");
	    return;
	}
    }

#   ifdef DEBUG
    IRIT_IF_DEBUG_ON_PARAMETER(_DebugIritPrsrDispNesting)
	strcat(Str, "[");    /* Useful to see ALL nestings - no preceedings. */
#   endif /* DEBUG */

    switch (i * 100) {
	case IP_USER_FUNC:
	    switch (Root -> NodeKind) {
		case IP_USERFUNCDEF:
		    Level = 0;
		    CloseFlag = TRUE;
		    strcat(Str, "function(");
		    break;
		case IP_USERPROCDEF:
		    Level = 0;
		    CloseFlag = TRUE;
		    strcat(Str, "procedure(");
		    break;
		case IP_USERINSTDEF:
		    Level = 0;
		    CloseFlag = TRUE;
		    strcat(Str, Root -> UserFunc -> FuncName);
		    strcat(Str, "(");
		    break;
	    }
	    break;

	case IP_NUM_FUNC:
	    Level = 0;
	    CloseFlag = TRUE;
            strcat(Str,
		   NumFuncTable[Root -> NodeKind - IP_NUM_FUNC_OFFSET].FuncName);
	    strcat(Str, "(");
	    break;

	case IP_OBJ_FUNC1:
	case IP_OBJ_FUNC2:
	case IP_OBJ_FUNC3:
	case IP_OBJ_FUNC4:
	    Level = 0;
	    CloseFlag = TRUE;
            strcat(Str,
		   ObjFuncTable[Root -> NodeKind - IP_OBJ_FUNC_OFFSET].FuncName);
	    strcat(Str, "(");
	    break;

	case IP_GEN_FUNC:
	    Level = 0;
	    CloseFlag = TRUE;
            strcat(Str,
		   GenFuncTable[Root -> NodeKind - IP_GEN_FUNC_OFFSET].FuncName);
	    strcat(Str, "(");
	    break;

	case IP_OPERATORS:
	    switch (Root -> NodeKind % IP_PRSR_MAX_TOKEN) {
		case IP_TKN_DIV:
		    if (Level > 1) {
			strcat(Str, "(");
		        CloseFlag = TRUE;
		    }
		    Level = 1;				       /* Div Level. */
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "/");
		    break;

		case IP_TKN_MINUS:
		    if (Level > 0) {
			strcat(Str, "(");
	        	CloseFlag = TRUE;
		    }
		    Level = 0;				     /* Minus Level. */
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "-");
		    break;

		case IP_TKN_MULT:
		    if (Level > 1) {
			strcat(Str, "(");
		        CloseFlag = TRUE;
		    }
		    Level = 1;				       /* Mul Level. */
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "*");
		    break;

		case IP_TKN_PLUS:
		    if (Level > 0) {
			strcat(Str, "(");
	        	CloseFlag = TRUE;
		    }
		    Level = 0;				      /* Plus Level. */
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "+");
		    break;

		case IP_TKN_POWER:
		    Level = 2;				     /* Power Level. */
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "^");
		    break;

		case IP_TKN_UNARMINUS:
		    strcat(Str, "(-");
		    Level = 0;
		    CloseFlag = TRUE;
		    break;

		case IP_TKN_COMMA:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, ",");
		    break;

		case IP_TKN_COLON:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, ":");
		    break;

		case IP_TKN_EQUAL:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "=");
		    break;

		case IP_TKN_CMP_EQUAL:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "==");
		    break;

		case IP_TKN_CMP_NOTEQUAL:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "!=");
		    break;

		case IP_TKN_CMP_LSEQUAL:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "<=");
		    break;

		case IP_TKN_CMP_GTEQUAL:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, ">=");
		    break;

		case IP_TKN_CMP_LESS:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "<");
		    break;

		case IP_TKN_CMP_GREAT:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, ">");
		    break;

		case IP_TKN_BOOL_OR:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "||");
		    break;

		case IP_TKN_BOOL_AND:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "&&");
		    break;

		case IP_TKN_BOOL_NOT:
		    LocalPrintTree(Root -> Left, Level, Str, StrLen);
		    strcat(Str, "!");
		    break;

		case IP_TKN_NUMBER:
		    sprintf(&Str[strlen(Str)], "%g", Root -> PObj -> U.R);
		    break;

		case IP_TKN_PARAMETER:
		    sprintf(&Str[strlen(Str)], "%s",
			    IP_GET_OBJ_NAME(Root -> PObj));
		    break;

		case IP_TKN_STRING:
		    sprintf(&Str[strlen(Str)], "\"%s\"",
			    Root -> PObj -> U.Str);
		    break;

		case IP_TKN_OPENPARA:
		    strcat(Str, "(");
		    break;

		case IP_TKN_CLOSPARA:
		    strcat(Str, ")");
		    break;

		case IP_TKN_START:
		    break;

		default:
		    IRIT_FATAL_ERROR("LocalPrintTree: Undefined ParseTree token to print, exit");
            }
            break;

	default:
	    IRIT_FATAL_ERROR("LocalPrintTree: Undefined ParseTree type to print, exit");
    }
    LocalPrintTree(Root -> Right, Level, Str, StrLen);
    if (CloseFlag)
	strcat(Str, ")");

#   ifdef DEBUG
    IRIT_IF_DEBUG_ON_PARAMETER(_DebugIritPrsrDispNesting)
	strcat(Str, "]");    /* Useful to see ALL nestings - no preceedings. */
#   endif /* DEBUG */
#endif /* !IRIT_QUIET_STRINGS */
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Duplicates a parse tree - Generates brand new ParseTree structure but      M
* binds to non-temp variables if they are exists - their Name is not NULL.   M
*   This means that updating these objects in the copied tree, will affect   M
* these objects in the original tree.					     M
*                                                                            *
* PARAMETERS:                                                                M
*   Root:     To duplicate.                                                  M
*                                                                            *
* RETURN VALUE:                                                              M
*   ParseTree *:   Duplicated parse tree                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrCopyTree                                                         M
*****************************************************************************/
ParseTree *InptPrsrCopyTree(ParseTree *Root)
{
    ParseTree *NewRoot;

    if (Root == NULL)
	return NULL;

    NewRoot = ExprMalloc();

    if (IP_IS_FUNCTION(Root -> NodeKind)) {	       /* All the functions. */
	NewRoot -> NodeKind = Root -> NodeKind;
	NewRoot -> Right = InptPrsrCopyTree(Root -> Right);
	if (IP_IS_USER_FUNCTION(Root -> NodeKind))
	    NewRoot -> UserFunc = Root -> UserFunc;
	return NewRoot;
    }

    switch (Root -> NodeKind) {
	case IP_TKN_DIV:
	case IP_TKN_MINUS:
	case IP_TKN_MULT:
	case IP_TKN_PLUS:
	case IP_TKN_POWER:

	case IP_TKN_COMMA:
	case IP_TKN_COLON:
	case IP_TKN_EQUAL:
	case IP_TKN_CMP_EQUAL:
	case IP_TKN_CMP_NOTEQUAL:
	case IP_TKN_CMP_LSEQUAL:
	case IP_TKN_CMP_GTEQUAL:
	case IP_TKN_CMP_LESS:
	case IP_TKN_CMP_GREAT:
        case IP_TKN_BOOL_OR:
        case IP_TKN_BOOL_AND:
	    NewRoot -> NodeKind = Root -> NodeKind;
	    NewRoot -> Right = InptPrsrCopyTree(Root -> Right);
	    NewRoot -> Left  = InptPrsrCopyTree(Root -> Left);
	    return NewRoot;

	case IP_TKN_UNARMINUS:
        case IP_TKN_BOOL_NOT:
	    NewRoot -> NodeKind = Root -> NodeKind;
	    NewRoot -> Right = InptPrsrCopyTree(Root -> Right);
	    NewRoot -> Left  = NULL;
	    return NewRoot;

	case IP_TKN_NUMBER:
	case IP_TKN_PARAMETER:
	case IP_TKN_STRING:
	    NewRoot -> NodeKind = Root -> NodeKind;
	    NewRoot -> PObj = Root -> PObj;	    /* Point on SAME object. */
	    NewRoot -> PObj -> Count++;      /* But increase its ref. count. */
	    return NewRoot;

	case IP_TKN_START:
	    NewRoot -> NodeKind = Root -> NodeKind;
	    return NewRoot;

	default:
	    IRIT_FATAL_ERROR("InptPrsrCopyTree: Undefined ParseTree type to copy, exit");
    }
    return NULL;				    /* Makes warning silent. */
}

/*****************************************************************************
* DESCRIPTION:                                                               M
* Routine to return evaluation error if happen one, zero elsewhere	     M
*                                                                            *
* PARAMETERS:                                                                M
*   Message:    Place here a message describing an error, if was one.        M
*                                                                            *
* RETURN VALUE:                                                              M
*   InptPrsrEvalErrType:  Type of evaluation error.                          M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptPrsrEvalError                                                        M
*****************************************************************************/
InptPrsrEvalErrType InptPrsrEvalError(char **Message)
{
    InptPrsrEvalErrType Temp;

    *Message = IPGlblCharData;
    Temp = IPGlblEvalError;
    IPGlblEvalError = IPE_NO_ERR;

    return Temp;
}

/*****************************************************************************
* DESCRIPTION:                                                               M
*   Given an object and a parse tree, updates the dependencies and	     M
* parameters of object PObj according to parse tree Root.		     M
*   Root is assumed to be of the form "PObjName = ..."			     M
*                                                                            *
* PARAMETERS:                                                                M
*   PObj:      To update its parameter dependency list.                      M
*   Root:      Expression that created PObj as "PObjName = ...".             M
*                                                                            *
* RETURN VALUE:                                                              M
*   void                                                                     M
*                                                                            *
* KEYWORDS:                                                                  M
*   InptEvalPropagateDependencies                                            M
*****************************************************************************/
void InptEvalPropagateDependencies(IPObjectStruct *PObj, ParseTree *Root)
{
    IRIT_STATIC_DATA unsigned int
	UpdateIndex = 1;
    char Str[IP_EXPR_MAX_STRING_LEN];
    IPODObjectDpndncyStruct
	*Dpnds = PObj -> Dpnds;

    if (Dpnds != NULL) {
	IPODParamsStruct *p;

	/* Free the parameters of this object as we are going to redo them. */
	/*   Note we first remove this object's name from all other objects */
	/* this object depends upon.					    */
	for (p = Dpnds -> ObjParams; p != NULL; p = p -> Pnext) {
	    IPObjectStruct
		*PObjParam = IritDBGetObjByName(p -> Name);

	    if (PObjParam != NULL)
		IPODDelDependencyFromObj(PObjParam -> Dpnds,
					 IP_GET_OBJ_NAME(PObj));
	}
	IPODFreeParametersOfObj(Dpnds -> ObjParams);
	Dpnds -> ObjParams = NULL;
	Dpnds -> NumParams = 0;

	if (Dpnds -> EvalExpr != NULL)
	    IritFree(Dpnds -> EvalExpr);
    }
    else
	PObj -> Dpnds = Dpnds = IPODNewDependencies();

    /* Now parse the parse tree and search for other objects and insert them */
    /* into the parameter list and insert this object into their dependency  */
    /* lists.								     */
    InptPrsrPrintTree(Root, Str, IP_EXPR_MAX_STRING_LEN);
    strcat(Str, ";");
    Dpnds -> EvalExpr = IritStrdup(Str);

#   ifdef DEBUG
    IRIT_IF_DEBUG_ON_PARAMETER(_DebugIritPrsrDepndncy)
        IRIT_INFO_MSG_PRINTF("Object \"%s\" eval expression:\n\t%s\n",
		             IP_GET_OBJ_NAME(PObj), Str);
#   endif /* DEBUG */

    InptPrsrPropagateDependencyObjects(PObj, Root);
    InptPrsrPropagateUpdatedObjects(PObj, UpdateIndex);

    /* Increment the propagation index only at top recursion level. */
    if (IritInputSource != IRIT_INPUT_SOURCE_LINE_QUEUE)
        UpdateIndex++;
}

/*****************************************************************************
* DESCRIPTION:                                                               *
* Scans the given tree for object names and set up dependencies upon.	     *
*                                                                            *
* PARAMETERS:                                                                *
*   PObj:      Object whose dependencies are to be updated.                  *
*   Root:      Of tree to scan for parameters.                               *
*                                                                            *
* RETURN VALUE:                                                              *
*   void                                                                     *
*****************************************************************************/
static void InptPrsrPropagateDependencyObjects(IPObjectStruct *PObj,
					       ParseTree *Root)
{
    if (!Root)
	return;

    if (IP_IS_FUNCTION(Root -> NodeKind)) {
	InptPrsrPropagateDependencyObjects(PObj, Root -> Right);
	return;
    }

    switch (Root -> NodeKind) {
	case IP_TKN_DIV:
	case IP_TKN_MINUS:
	case IP_TKN_MULT:
	case IP_TKN_PLUS:
	case IP_TKN_POWER:
	case IP_TKN_COMMA:
	case IP_TKN_COLON:
	case IP_TKN_EQUAL:
	case IP_TKN_CMP_EQUAL:
	case IP_TKN_CMP_NOTEQUAL:
	case IP_TKN_CMP_LSEQUAL:
	case IP_TKN_CMP_GTEQUAL:
	case IP_TKN_CMP_LESS:
	case IP_TKN_CMP_GREAT:
	case IP_TKN_BOOL_OR:
	case IP_TKN_BOOL_AND:
	    InptPrsrPropagateDependencyObjects(PObj, Root -> Right);
	    InptPrsrPropagateDependencyObjects(PObj, Root -> Left);
	    break;

	case IP_TKN_UNARMINUS:
	case IP_TKN_BOOL_NOT:
	    InptPrsrPropagateDependencyObjects(PObj, Root -> Right);
	    break;

	case IP_TKN_PARAMETER:
	    if (Root -> PObj) {
		IPObjectStruct
		    *PObjParam =
		         IritDBGetObjByName(IP_GET_OBJ_NAME(Root -> PObj));

		/* Let the other object know we depend on it. */
		if (PObjParam != NULL &&
		    strcmp(IP_GET_OBJ_NAME(PObj),
			   IP_GET_OBJ_NAME(PObjParam)) != 0) {
		    IPODAddDependencyToObj(&PObjParam -> Dpnds,
					   IP_GET_OBJ_NAME(PObj));

		    /* Place the other object's name as our parameter. */
		    IPODAddParameterToObj(&PObj -> Dpnds,
					  IP_GET_OBJ_NAME(PObjParam));

#		    ifdef DEBUG
		    IRIT_IF_DEBUG_ON_PARAMETER(_DebugIritPrsrDepndncy)
			IRIT_INFO_MSG_PRINTF(
				"Object \"%s\" - add \"%s\" as a parameter\n",
				IP_GET_OBJ_NAME(PObj),
				IP_GET_OBJ_NAME(PObjParam));
#		    endif /* DEBUG */
		}
	    }
	    break;

	default:
	    break;
    }
}

/*****************************************************************************
* DESCRIPTION:                                                               *
*   Recursively update all objects that depend on PObj.                      *
*                                                                            *
* PARAMETERS:                                                                *
*   PObj:      An object that was modified to propagate.                     *
*   UpdateIndex:  Index of this update/propagation session.	             *
*                                                                            *
* RETURN VALUE:                                                              *
*   void                                                                     *
*****************************************************************************/
static void InptPrsrPropagateUpdatedObjects(IPObjectStruct *PObj,
					    int UpdateIndex)
{
    IPODObjectDpndncyStruct
	*Dpnds = PObj -> Dpnds;
    IPODDependsStruct *p;

#   ifdef DEBUG
    IRIT_IF_DEBUG_ON_PARAMETER(_DebugIritPrsrDepndncy)
        IRIT_INFO_MSG_PRINTF(
		"Object %s with index %d and visit #%d, Global index %d\n",
		IP_GET_OBJ_NAME(PObj), Dpnds -> EvalIndex,
		Dpnds -> NumVisits, UpdateIndex);
#   endif /* DEBUG */

    if (Dpnds -> EvalIndex == UpdateIndex) {
        if (++Dpnds -> NumVisits > Dpnds -> NumParams)
	    IRIT_NON_FATAL_ERROR("Cycles detected in dependencies; aborted");
	return;
    }
    else {
	Dpnds -> EvalIndex = UpdateIndex;
	Dpnds -> NumVisits = 1;
    }

    /* Scan all objects that depends on this object and reevaluate them. */
    for (p = Dpnds -> ObjDepends; p != NULL; p = p -> Pnext) {
        IPObjectStruct
	    *PObjDepend = IritDBGetObjByName(p -> Name);

	if (PObjDepend != NULL) {
	    IPODObjectDpndncyStruct
	        *Dpnds2 = PObjDepend -> Dpnds;

	    if (Dpnds2 != NULL) {
	        if (Dpnds2 -> EvalExpr != NULL) {
		    /* Evaluate expression that created object PObjDepend. */
		    InptPrsrQueueInputLine(Dpnds2 -> EvalExpr);
		    if (GlblHandleDependencies == 2)
		        IRIT_INFO_MSG_PRINTF("Reeval: %s\n",
				             Dpnds2 -> EvalExpr);
		}
	    }
	}
    }
}
